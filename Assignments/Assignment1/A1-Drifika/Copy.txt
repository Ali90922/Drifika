/**
 * Read data from a file.
 */
/**
 * Read from a file desriptor.
 *
 * Parameters:
 *  * fd: The file descriptor to read from. Must be a nonnegative integer. The
 *        file descriptor should refer to a file, not a directory.
 *  * buffer: The buffer to read data into. Must not be NULL.
 *  * count: The number of bytes to read into the buffer.
 * Return: The number of bytes read, 0 at the end of the file, or -1 on error.
 */
ssize_t nqp_read(int fd, void *buffer, size_t count)
{
    if (!is_mounted || fd < 2 || !buffer || count == 0)
    {
        return -1; // Invalid parameters
    }

    uint32_t current_cluster = fd; // fd is the first cluster number

    // The left shift in the single bit is to raise the value to the power of 2 :
    uint32_t cluster_size = (1 << mbr.bytes_per_sector_shift) * (1 << mbr.sectors_per_cluster_shift); // Total bytes per cluster

    size_t bytes_read = 0;

    size_t bytes_to_read = count;
    uint8_t *cluster_buffer = malloc(cluster_size);

    if (!cluster_buffer)
    {
        return -1; // Memory allocation failure
    }

    while (bytes_to_read > 0 && current_cluster != 0xFFFFFFFF) // 0xFFFFFFFF = End of file
    {
        // Compute the offset in the exFAT image
        uint64_t cluster_offset = (mbr.cluster_heap_offset * (1 << mbr.bytes_per_sector_shift)) + (current_cluster - 2) * cluster_size;

        // cluster_heap_offset is the start location of the file data in the exFAT
        // current_cluster - 2 is there to convert the cluster number to index - since cluster numbers start from 2.
        // So the final offset being calculated is : (Start of Cluster Heap) + (Offset of current cluster)

        fseek(fs_image, cluster_offset, SEEK_SET);
        if (fread(cluster_buffer, cluster_size, 1, fs_image) != 1)
        {
            free(cluster_buffer);
            return -1; // Error reading from file system
        }

        // Read the requested bytes
        size_t bytes_from_cluster = (bytes_to_read < cluster_size) ? bytes_to_read : cluster_size;
        memcpy((char *)buffer + bytes_read, cluster_buffer, bytes_from_cluster);

        bytes_read += bytes_from_cluster;
        bytes_to_read -= bytes_from_cluster;

        // Move to the next cluster in the file
        fseek(fs_image, (mbr.fat_offset * (1 << mbr.bytes_per_sector_shift)) + (current_cluster * sizeof(uint32_t)), SEEK_SET);
        fread(&current_cluster, sizeof(uint32_t), 1, fs_image);
    }

    free(cluster_buffer);
    return bytes_read; // Return number of bytes read
} /**
   * Read data from a file.
   */
/**
 * Read from a file desriptor.
 *
 * Parameters:
 *  * fd: The file descriptor to read from. Must be a nonnegative integer. The
 *        file descriptor should refer to a file, not a directory.
 *  * buffer: The buffer to read data into. Must not be NULL.
 *  * count: The number of bytes to read into the buffer.
 * Return: The number of bytes read, 0 at the end of the file, or -1 on error.
 */
ssize_t nqp_read(int fd, void *buffer, size_t count)
{
    if (!is_mounted || fd < 2 || !buffer || count == 0)
    {
        return -1; // Invalid parameters
    }

    uint32_t current_cluster = fd; // fd is the first cluster number

    // The left shift in the single bit is to raise the value to the power of 2 :
    uint32_t cluster_size = (1 << mbr.bytes_per_sector_shift) * (1 << mbr.sectors_per_cluster_shift); // Total bytes per cluster

    size_t bytes_read = 0;

    size_t bytes_to_read = count;
    uint8_t *cluster_buffer = malloc(cluster_size);

    if (!cluster_buffer)
    {
        return -1; // Memory allocation failure
    }

    while (bytes_to_read > 0 && current_cluster != 0xFFFFFFFF) // 0xFFFFFFFF = End of file
    {
        // Compute the offset in the exFAT image
        uint64_t cluster_offset = (mbr.cluster_heap_offset * (1 << mbr.bytes_per_sector_shift)) + (current_cluster - 2) * cluster_size;

        // cluster_heap_offset is the start location of the file data in the exFAT
        // current_cluster - 2 is there to convert the cluster number to index - since cluster numbers start from 2.
        // So the final offset being calculated is : (Start of Cluster Heap) + (Offset of current cluster)

        fseek(fs_image, cluster_offset, SEEK_SET);
        if (fread(cluster_buffer, cluster_size, 1, fs_image) != 1)
        {
            free(cluster_buffer);
            return -1; // Error reading from file system
        }

        // Read the requested bytes
        size_t bytes_from_cluster = (bytes_to_read < cluster_size) ? bytes_to_read : cluster_size;
        memcpy((char *)buffer + bytes_read, cluster_buffer, bytes_from_cluster);

        bytes_read += bytes_from_cluster;
        bytes_to_read -= bytes_from_cluster;

        // Move to the next cluster in the file
        fseek(fs_image, (mbr.fat_offset * (1 << mbr.bytes_per_sector_shift)) + (current_cluster * sizeof(uint32_t)), SEEK_SET);
        fread(&current_cluster, sizeof(uint32_t), 1, fs_image);
    }

    free(cluster_buffer);
    return bytes_read; // Return number of bytes read
}